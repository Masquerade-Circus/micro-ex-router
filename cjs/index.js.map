{"version":3,"file":"index.js","sources":["../lib/index.js"],"sourcesContent":["let micro = require('micro'),\n    urlencodedBodyParser = require('urlencoded-body-parser'),\n    url = require('url'),\n    qs = require('querystring');\n\nlet acceptedMethods = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options'];\n\n/**\n * Adds a path to a router\n * @method addPath\n * @param  {Router} router              The router in which to add the path\n * @param  {String} method              The method that will handle this path\n * @param  {String} path                The path to handle\n * @param  {Function|Array} middleware  Middleware function or an array of middlewares to be called when the path matches\n */\nlet addPath = (router, method, path, middleware) => {\n    // Find the params like express params\n    let params = path.match(/:(\\w+)?/gi) || [];\n\n    // Set the names of the params found\n    for (let i in params) {\n        params[i] = params[i].replace(':', '');\n    }\n\n    // Adds the path to the selected method\n    router.paths[method][path] = {\n        // RegExp that will be used to match against the requested path\n        regexp : new RegExp('^' + path.replace(/:(\\w+)/gi, '([^\\\\s\\\\/]+)') + '/?(\\\\?.*)?$', 'gi'),\n        // The name of the params if any\n        params: params,\n        // The middleware(s) to call when this path matches\n        middleware: middleware\n    };\n\n    // return the pased router\n    return router;\n};\n\n\nlet RouterFactory = (options = {}) => {\n    let opt = Object.assign({}, { limit: '1mb', encoding: 'utf8' }, options);\n\n    /**\n     * new Rotuer\n     * @param  {Request}    req     NodeJs Request object\n     * @param  {Response}   res     NodeJs Response object\n     * @return {Function}           The async function to be passed to micro\n     */\n    let Router = async function (req, res) {\n        let urls = Router.paths[req.method.toLowerCase()];\n        let middleware;\n\n        // Find first matched url\n        for (let i in urls) {\n            let matches = urls[i].regexp.exec(req.url);\n            urls[i].regexp.lastIndex = -1;\n            if (Array.isArray(matches)) {\n                matches.shift();\n                await Router.parseBody(req);\n                let k = urls[i].params.length;\n                for (; k--;) {\n                    req.params[urls[i].params[k]] = matches[k];\n                }\n                middleware = urls[i].middleware;\n                break;\n            }\n        }\n\n        // If there is an url match\n        if (middleware !== undefined) {\n            let response;\n\n            // Call the use middlewares\n            let l = Router.useMiddlewares.length, i = 0;\n\n            for (; i < l; i++) {\n                response = await Router.useMiddlewares[i](req, res);\n                if (response !== undefined && !res.headersSent) {\n                    return response;\n                }\n            }\n\n            // if middleware is an array of middlewares call them sequentially\n            if (Array.isArray(middleware)) {\n                let l = middleware.length, i = 0;\n                // call sequentially every middleware\n                for (; i < l; i++) {\n                    response = await middleware[i](req, res);\n                    if (response !== undefined && !res.headersSent) {\n                        return response;\n                    }\n                }\n            }\n\n            // If middleware it's not an array, call it and return its response\n            return await middleware(req, res);\n        }\n\n        // If no url is matched throw a new error\n        throw new Error(`The url ${req.url} requested by ${req.method.toLowerCase()}, wasn't found`);\n    };\n\n    /**\n     * Where to store the paths and its middlewares\n     * @type {Object}\n     */\n    Router.paths = {};\n\n    /**\n     * Where to store the use middlewares\n     * @type {Array}\n     */\n    Router.useMiddlewares = [];\n\n    /**\n     * Use method to add middlewares for every path\n     * @method use\n     * @param  {Function} middleware    The middleware to add\n     * @return {Router}\n     */\n    Router.use = middleware => {\n        Router.useMiddlewares.push(middleware);\n        return Router;\n    };\n\n    /**\n     * For each accepted method, add the method to the router\n     * @type {Array}\n     */\n    acceptedMethods.map(method => {\n        Router.paths[method] = {};\n        Router[method] = (path, middleware) => addPath(Router, method, path, middleware);\n    });\n\n    /**\n     * Parses the body according with its content-type\n     * @method parseBody\n     * @param  {Request}    req\n     * @return {Void}\n     */\n    Router.parseBody = async (req) => {\n        /**\n         * Set the params property to an empty object\n         * @type {Object}\n         */\n        req.params = req.params || {};\n\n        /**\n         * Set the body property to undefined\n         * @type {Undefined}\n         */\n        req.body = undefined;\n\n        /**\n         * Set the query object\n         * The object returned by the querystring.parse() method does not prototypically inherit from the JavaScript Object.\n         * So we create a new object and merge its properties\n         * @type {Object}\n         */\n        req.query = Object.assign({}, qs.parse(url.parse(req.url).query));\n\n        /**\n         * If the method is other than get try to parse the body\n         * @method if\n         * @param  {Request} req\n         */\n        if (req.method.toLowerCase() !== 'get') {\n            let type = req.headers['content-type'],\n                parsed = false,\n                options = {\n                    limit: opt.limit,\n                    encoding: opt.encoding\n                },\n                body;\n\n            try {\n                if (type === 'application/json') {\n                    parsed = true;\n                    body = await micro.json(req, options);\n                }\n\n                if (type === 'application/x-www-form-urlencoded' && !parsed) {\n                    parsed = true;\n                    body = await urlencodedBodyParser(req, options);\n                }\n\n                if (type === 'text/html' && !parsed) {\n                    parsed = true;\n                    body = await micro.text(req, options);\n                }\n\n                if (!parsed) {\n                    body = await micro.buffer(req, options);\n                }\n            } catch (e) {\n\n            }\n\n            req.body = body;\n        }\n    };\n\n    /**\n     * Return the new router\n     * @type {Router}\n     */\n    return Router;\n};\n\nmodule.exports = RouterFactory;\n"],"names":["acceptedMethods","addPath","router","method","path","middleware","params","match","i","replace","paths","RegExp","RouterFactory","options","opt","Object","assign","limit","encoding","Router","req","res","toLowerCase","urls","regexp","exec","url","lastIndex","Array","isArray","matches","shift","parseBody","length","k","undefined","useMiddlewares","l","response","headersSent","Error","use","push","map","body","query","qs","parse","headers","parsed","type","micro","json","urlencodedBodyParser","text","buffer"],"mappings":"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"}