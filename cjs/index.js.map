{"version":3,"file":"index.js","sources":["../lib/index.js"],"sourcesContent":["let micro = require('micro'),\n    urlencodedBodyParser = require('urlencoded-body-parser'),\n    url = require('url'),\n    qs = require('querystring');\n\nlet acceptedMethods = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options'];\n\n/**\n * Adds a path to a router\n * @method addPath\n * @param  {Router} router              The router in which to add the path\n * @param  {String} method              The method that will handle this path\n * @param  {String} path                The path to handle\n * @param  {Function|Array} middleware  Middleware function or an array of middlewares to be called when the path matches\n */\nlet addPath = (router, method, path, middleware) => {\n    // Find the params like express params\n    let params = path.match(/:(\\w+)?/gi);\n\n    // Set the names of the params found\n    if (Array.isArray(params)) {\n        for (let i in params) {\n            params[i] = params[i].replace(':', '');\n        }\n    }\n\n    // Adds the path to the selected method\n    router.paths[method][path] = {\n        // RegExp that will be used to match against the requested path\n        regexp : () => new RegExp('^' + path.replace(/:(\\w+)/gi, \"(\\\\w+)\") + '/?(\\\\?.*)?$', 'gi'),\n        // The name of the params if any\n        params: params,\n        // The middleware(s) to call when this path matches\n        middleware: middleware\n    };\n\n    // return the pased router\n    return router;\n};\n\n\nlet RouterFactory = (options = {}) => {\n    let opt = Object.assign({}, { limit: '1mb', encoding: 'utf8' }, options);\n\n    /**\n     * new Rotuer\n     * @param  {Request}    req     NodeJs Request object\n     * @param  {Response}   res     NodeJs Response object\n     * @return {Function}           The async function to be passed to micro\n     */\n    let Router = async function (req, res) {\n        let urls = Router.paths[req.method.toLowerCase()];\n        let middleware;\n\n        // Find first matched url\n        for (let i in urls) {\n            let matches = urls[i].regexp().exec(req.url);\n            if (Array.isArray(matches)) {\n                matches.shift();\n                for (let k in urls[i].params) {\n                    req.params[urls[i].params[k]] = matches[k];\n                }\n                middleware = urls[i].middleware;\n                break;\n            }\n        }\n\n        // If there is an url match\n        if (middleware !== undefined) {\n            let response;\n\n            // Call the use middlewares\n            let l = Router.useMiddlewares.length, i = 0;\n\n            for (; i < l; i++) {\n                response = await Router.useMiddlewares[i](req, res);\n                if (response !== undefined || res.headersSent) {\n                    return response;\n                }\n            }\n\n            // if middleware is an array of middlewares call them sequentially\n            if (Array.isArray(middleware)) {\n                let l = middleware.length, i = 0;\n                // call sequentially every middleware\n                for (; i < l; i++) {\n                    response = await middleware[i](req, res);\n                    if (response !== undefined || res.headersSent) {\n                        return response;\n                    }\n                }\n            }\n\n            // If middleware it's not an array, call it and return its response\n            return await middleware(req, res);\n        }\n\n        // If no url is matched throw a new error\n        throw new Error(`The url ${req.url} requested by ${req.method.toLowerCase()}, wasn't found`);\n    };\n\n    /**\n     * Where to store the paths and its middlewares\n     * @type {Object}\n     */\n    Router.paths = {};\n\n    /**\n     * Where to store the use middlewares\n     * @type {Array}\n     */\n    Router.useMiddlewares = [];\n\n    /**\n     * Use method to add middlewares for every path\n     * @method use\n     * @param  {Function} middleware    The middleware to add\n     * @return {Router}\n     */\n    Router.use = middleware => {\n        Router.useMiddlewares.push(middleware);\n        return Router;\n    };\n\n    /**\n     * For each accepted method, add the method to the router\n     * @type {Array}\n     */\n    acceptedMethods.map(method => {\n        Router.paths[method] = {};\n        Router[method] = (path, middleware) => addPath(Router, method, path, middleware);\n    });\n\n    Router.use(async (req, res) => {\n        /**\n         * Set the params property to an empty object\n         * @type {Object}\n         */\n        req.params = {};\n\n        /**\n         * Set the body property to undefined\n         * @type {Undefined}\n         */\n        req.body = undefined;\n\n        /**\n         * Set the query object\n         * The object returned by the querystring.parse() method does not prototypically inherit from the JavaScript Object.\n         * So we create a new object and merge its properties\n         * @type {Object}\n         */\n        req.query = Object.assign({}, qs.parse(url.parse(req.url).query));\n\n        /**\n         * If the method is other than get try to parse the body\n         * @method if\n         * @param  {Request} req\n         */\n        if (req.method.toLowerCase() !== 'get') {\n            let type = req.headers['content-type'],\n                parsed = false,\n                options = {\n                    limit: opt.limit,\n                    encoding: opt.encoding\n                },\n                body;\n\n            try {\n                if (type === 'application/json') {\n                    parsed = true;\n                    body = await micro.json(req, options);\n                }\n\n                if (type === 'application/x-www-form-urlencoded' && !parsed) {\n                    parsed = true;\n                    body = await urlencodedBodyParser(req, options);\n                }\n\n                if (type === 'text/html' && !parsed) {\n                    parsed = true;\n                    body = await micro.text(req, options);\n                }\n\n                if (!parsed) {\n                    body = await micro.buffer(req, options);\n                }\n            } catch (e) {\n\n            }\n\n            req.body = body;\n        }\n    });\n\n    /**\n     * Return the new router\n     * @type {Router}\n     */\n    return Router;\n};\n\nmodule.exports = RouterFactory;\n"],"names":["acceptedMethods","addPath","router","method","path","middleware","params","match","Array","isArray","i","replace","paths","RegExp","RouterFactory","options","opt","Object","assign","limit","encoding","Router","req","res","toLowerCase","urls","regexp","exec","url","matches","shift","k","undefined","useMiddlewares","length","l","response","headersSent","Error","use","push","map","body","query","qs","parse","headers","parsed","type","micro","json","urlencodedBodyParser","text","buffer"],"mappings":"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"}